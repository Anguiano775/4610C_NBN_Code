#pragma config(Sensor, in5,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl5,  centerEncoder,  sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, shootLimitLeft, sensorTouch)
#pragma config(Sensor, dgtl12, shootLimitRight, sensorTouch)
#pragma config(Motor,  port2,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontR,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightShooter,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           ballDirection, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftShooter,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           frontLeft,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int frontRight = frontR;
void maxGyro(int deg);

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
int shootFunctioningLeft = 0;
int shootFunctioningRight = 0;
int controlOfDrive = 0;
void leftshoot()
{
	shootFunctioningLeft = 1;
	motor[leftShooter] = 127;
	wait1Msec(1000);
	writeDebugStreamLine("In leftshoot");
	while(SensorValue[shootLimitLeft] == 0 && !vexRT[Btn7L]){wait1Msec(50)}
	writeDebugStreamLine("exit leftshoot");
	motor[leftShooter] = 18;
	shootFunctioningLeft = 0;

}
void rightshoot()
{
	shootFunctioningRight = 1;
	motor[rightShooter] = 127;
	wait1Msec(1000);
	writeDebugStreamLine("In rightshoot");
	while(SensorValue[shootLimitRight] == 0 && !vexRT[Btn7L]){wait1Msec(50)};
	writeDebugStreamLine("exit rightshoot");
	motor[rightShooter] = 18;
	shootFunctioningRight = 0;
}
#define M_PI 3.1415
// Converts degrees to radians.
#define degreesToRadians(angleDegrees) (angleDegrees * M_PI / 180.0)

// Converts radians to degrees.
#define radiansToDegrees(angleRadians) (angleRadians * 180.0 / M_PI)
#define trackwidth ((15.5)/12)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
typedef struct TYPE_POS
{
	float x;
	float y;
	float z;

	float x_tile;
	float y_tile

	float oldFWD;
	float oldSTR;
	float oldAngle;


	float distance_from_goal;
	float angle_to_turn;
	float angle_from_goal;




} TYPE_POS;

typedef struct {
	float leftEncoder;
	float rightEncoder;
	float centerEncoder;
	int gyroValue;

} ENCODER_DATA;
ENCODER_DATA eData;
TYPE_POS pData;
const int RED = 0;
const int BLUE = 1;
int alliance = BLUE;
const int DRIVER_BOX_SQUARE = 0;
const int FIELD_WALL_SQUARE = 1;
int starting_square = DRIVER_BOX_SQUARE;
task FPS {
	int GYRO_OFFSET = 900;
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	SensorValue[centerEncoder] = 0;
	SensorValue[gyro] = 0;
	if(alliance == BLUE)
	{
	pData.x = starting_square == DRIVER_BOX_SQUARE ? 2 : 1;
	pData.y = starting_square == DRIVER_BOX_SQUARE ? 1 : 2;
	}
	else if(alliance == RED)
	{
	pData.x = starting_square == DRIVER_BOX_SQUARE ? 9 : 11;
	pData.y = starting_square == DRIVER_BOX_SQUARE ? 1 : 2;
	}
	clearTimer(T1);
	while(1){
		float FWD, STR, RCW, dF, dS, dR;
		eData.leftEncoder = ((SensorValue[leftEncoder] / 360) * 10.205) / 12;  // Rotations * Circumfirence / 12
		eData.rightEncoder = ((SensorValue[rightEncoder] / 360) * 10.205) / 12;  // Rotations * Circumfirence / 12
		eData.centerEncoder = ((-SensorValue[centerEncoder] / 360) * 10.205) / 12;  // Rotations * Circumfirence / 12
		eData.gyroValue = SensorValue[gyro];

		// get updated follower wheel data
		FWD=(eData.leftEncoder+eData.rightEncoder)/2;           // feet
		STR=eData.centerEncoder;                 // feet
		RCW=degreesToRadians(eData.gyroValue/10);  // radians

		// compute the motions for this time step:
		dF=FWD-pData.oldFWD;  // feet
		dS=STR-pData.oldSTR;  // feet
		dR=RCW-pData.oldAngle;  // radians

		// compute new X, Y, Q position & orientation:
		pData.z+=dR/2;
		pData.y+=dF*sin(pData.z)+dS*cos(pData.z);
		pData.x+=dF*cos(pData.z)-dS*sin(pData.z);
		pData.z+=dR/2;

		pData.x_tile = pData.x * 12;
		pData.y_tile = pData.y * 12;

		// save for next iteration:
		pData.oldFWD=FWD;
		pData.oldSTR=STR;
		pData.oldAngle=RCW;
		if(alliance == BLUE)
		{
			pData.distance_from_goal = sqrt( pow(144-pData.x_tile,2) + pow(144-pData.y_tile,2) );
			int dx = 144-pData.x_tile;
			int dy = 144-pData.y_tile;
			pData.angle_from_goal = radiansToDegrees(atan(dx/dy));
		}
		else if(alliance = RED)
		{
			pData.distance_from_goal = sqrt( pow(144-pData.x_tile,2) + pow(0-pData.y_tile,2) );
			int dx = 144-pData.x_tile;
			int dy = 0-pData.y_tile;
			pData.angle_from_goal = radiansToDegrees(atan(dx/dy));
		}

		//writeDebugStreamLine("%d, %d, %d, %d, %d, %f, %f", Time10[T1], sensorValue[leftEncoder], sensorValue[rightEncoder], sensorValue[centerEncoder], sensorValue[gyro], pData.x, pData.y);
		wait1Msec(30);
	}
}

int CONROLOFDRIVE = 0;
int error;
float kP = 0.35;
int goal;
int errorForStop = 50; // 5 Degress * 10 Counts/Degree
void maxgyro(int deg) // Turn By Gyroscope
{
	controlOfDrive = 1;
	int deg10 = 10.8*deg;
	if(deg10 > 0)
	{
		deg10 += SensorValue[gyro];
		while(abs(SensorValue[gyro]) < abs(deg10))
		{
			motor[frontLeft] = 50;
			motor[backRight] = 50;
			motor[frontRight] = -50;
			motor[backLeft] = -50;
		}
		motor[frontLeft] = -10;
		motor[backRight] = -10;
		motor[frontRight] = 10;
		motor[backLeft] = 10;
		wait1Msec(200);
	}
	else
	{
		deg10 -= SensorValue[gyro];
		while(abs(SensorValue[gyro]) < abs(deg10))
		{
			motor[frontLeft] = -50;
			motor[backRight] = -50;
			motor[frontRight] = 50;
			motor[backLeft] = 50;
		}
		motor[frontLeft] = 50;
		motor[backRight] = 50;
		motor[frontRight] = -50;
		motor[backLeft] = -50;
		wait1Msec(200);
	}
	motor[frontLeft] = 0;
	motor[backRight] = -0;
	motor[frontRight] = -0;
	motor[backLeft] = -0;
	controlOfDrive = 0;
}


const int LEFT = 0;
const int RIGHT = 1;
int shooter = LEFT;

const int FULL_COURT = 0;
const int HALF_COURT = 1;
int leftShooterSetup = FULL_COURT;
int rightShooterSetup = HALF_COURT;

int ballReadyToLoad = 0;
int leftBallLoaded = 0;
int rightBallLoaded = 0;
int controlOfIntake = 0;
task checkLoaded
{
	ballReadyToLoad = 0;
	leftBallLoaded = 0;
	rightBallLoaded = 0;
}
void alignWithGoal()
{
	int angleToTurn = pData.angle_from_goal - (SensorValue[gyro]/10);
	if(alliance == RED)
		if(shooter == LEFT)
		angleToTurn += 3
	else
		angleToTurn += -3
	if(alliance == BLUE)
		if(shooter == LEFT)
		angleToTurn += -3
	else
		angleToTurn += 3
	maxgyro(angleToTurn);
}
void loadLeftShooter() // Stop = Btn6D
{
	controlOfIntake = 1;
	clearTimer(T4);
	while(!leftBallLoaded && !vexRT[Btn6D] && time1[T4] < 1250)
	{
		motor[intake] = -127;
		motor[ballDirection] = -127;
	}
	motor[intake] = 0;
	motor[ballDirection] = 0;
	controlOfIntake = 0;
}
void loadRightShooter() // Stop = Btn6D
{
	controlOfIntake = 1;
	clearTimer(T4);
	while(!rightBallLoaded && !vexRT[Btn6D] && time1[T4] < 1250)
	{
		motor[intake] = -127;
		motor[ballDirection] = 127;
	}
	motor[intake] = 0;
	motor[ballDirection] = 0;
	controlOfIntake = 0;
}
task leftShootTask
{
	while(1)
	{
		if(vexRT[Btn8D])
		{
			leftShoot();
		}
	}
}
task rightShootTask
{
	while(1)
	{
		if(vexRT[Btn7D])
		{
			rightshoot();
		}
	}
}
task shooterRoutine
{
	startTask(leftShootTask);
	startTask(rightShootTask);

}

void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}

int count = 0;
void pre_auton()
{

	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...


	//------------- Beginning of User Interface Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	const short leftButton = 1;
	const short centerButton = 2;
	const short rightButton = 4;

	//Loop while center button is not pressed
	while(nLCDButtons != centerButton && bIfiRobotDisabled)
	{
		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "Far Shot");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 4;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "Close Shot");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "No Auto");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "Programming");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 4:
			//Display fourth choice
			displayLCDCenteredString(0, "Blocking Auto");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:
			count = 0;
			break;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
int lefthit = 0;
int righthit  = 0;
task leftshootTask
{
	while(1)
	{
	leftshoot();
	wait1Msec(750);
}
}
task rightshootTask
{
	while(1)
	{
	rightshoot();
	wait1Msec(750);
}
}
task autonomous()
{
	if(count == 0) // Far Shoot
	{
		motor[leftShooter] =127;
	motor[rightShooter]=127;
	SensorValue[shootLimitLeft] == 0 && SensorValue[shootLimitRight] == 1
	while(SensorValue[shootLimitLeft] == 0 || SensorValue[shootLimitRight] == 0)
	{
		if(SensorValue[shootLimitLeft])
			motor[leftShooter] =18;
		if(SensorValue[shootLimitRight])
			motor[rightShooter] =18;
	}
	// Load
	motor[ballDirection] = 127;
	motor[intake] = -127;
	wait1Msec(1500);
	motor[ballDirection] = -127;
	wait1Msec(600);
	motor[intake] = -127;
	wait1Msec(1500);
	motor[ballDirection] = 127;
	wait1Msec(600);
	motor[leftShooter] =127;
	motor[rightShooter]=127;
	wait1Msec(1000);
	motor[leftShooter] =18;
	motor[rightShooter]=18;
	}
	if(count == 1) // close Shoot
	{
		motor[frontR] = -127;
		motor[frontLeft]= 127;
		motor[backLeft]= 127;
		motor[backRight]= -127;
		wait1Msec(2850);
		motor[frontR] = 0;
		motor[frontLeft]= -0;
		motor[backLeft]= -0;
		motor[backRight]= 0;
		leftshoot();
		rightshoot();
		motor[ballDirection] = 127;
		motor[intake] = -127;
		wait1Msec(1500);
		motor[ballDirection] = -127;
		wait1Msec(800);
		motor[ballDirection] = 75;
		wait1Msec(250);
		rightshoot();
	}
	if(count == 2) // No Auto
	{
	}
	if(count == 3) // Programming Skills
	{
		startTask(leftShootTask);
		startTask(rightShootTask);
		while(1);
	}
	if(count == 4) // Blocking Autp
	{
		motor[frontR] = 127;
		motor[frontLeft]= -127;
		motor[backLeft]= -127;
		motor[backRight]= 127;
		wait1Msec(3200);
		motor[frontR] = 0;
		motor[frontLeft]= -0;
		motor[backLeft]= -0;
		motor[backRight]= 0;
	}
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
int flipDrive = 1;
float slowdown = 1;
task driveFlip
{
	while(1)
	{
		if(vexRT[Btn8U])
		{
			while(vexRT[Btn8U]);
			flipDrive = flipDrive == 1 ? -1 : 1;
			writeDebugStreamLine("google");
		}
		if(vexRT[Btn8R])
		{
			while(vexRT[Btn8R]);
			slowdown = slowdown == 1 ? 0.5 : 1;
			writeDebugStreamLine("bing");
		}
		wait1Msec(50);
	}
}
task usercontrol()
{
	startTask(shooterRoutine);
	startTask(driveFlip);
	while (true)
	{
		const int ON = 1;
		const int OFF = 0;
		int fieldDrive = OFF;
		int strafe = vexRT[Ch1] * flipDrive * slowdown;
		int fwd = vexRT[Ch2] * flipDrive * slowdown;
		if(fieldDrive == ON)
		{
			float curr_gyro_angle_radians = SensorValue[gyro]/10 * pi/180;
			float temp = fwd * cos( curr_gyro_angle_radians ) + strafe * sin( curr_gyro_angle_radians);
			strafe = -fwd * sin( curr_gyro_angle_radians ) + strafe * cos( curr_gyro_angle_radians );
			fwd = temp;
		}
		if(controlOfDrive == 0)
		{
			motor[frontR] = fwd - strafe- vexRT[Ch4];
			motor[frontLeft]= -fwd - strafe - vexRT[Ch4];
			motor[backLeft]= -fwd + strafe - vexRT[Ch4];
			motor[backRight]= fwd + strafe - vexRT[Ch4];
		}
		if(controlOfIntake == 0)
		{
			if(vexRT[Btn6U])
			{
				motor[intake] = -127;
			}
			else if(vexRT[Btn5U])
			{
				motor[intake] = 75;
			}
			else
			{
				motor[intake] = 0;
			}
			if(vexRT[Btn6D])
			{
				motor[ballDirection] = 127;
			}
			else if(vexRT[Btn5D])
			{
				motor[ballDirection] = -127;
			}
			else
			{
				motor[ballDirection] = 0;
			}
			if(vexRT[Btn7U])
			{
				motor[leftShooter] = 127;
				motor[rightShooter] = 127;
			}
			else if(shootFunctioningLeft == 0 && shootFunctioningRight == 0)
			{
				if(vexRT[Btn7R])
				{
					motor[rightShooter] = -80;;
				}
				else
				{
					motor[rightShooter] = 0;
				}
				if(vexRT[Btn8L])
				{
					motor[leftShooter] = -80;
				}
				else
				{
					motor[leftShooter] = 0;
				}

			}
			if(vexRT[Btn7R])
			{
				motor[port1] = 75;
			}
			else if(vexRT[Btn7L])
			{
				motor[port1] = -40;
			}
			else
			{
				motor[port1] = 0;
			}

		}
	}
}
