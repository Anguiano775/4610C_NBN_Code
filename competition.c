#pragma config(Sensor, in5,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl5,  centerEncoder,  sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, shootLimitLeft, sensorTouch)
#pragma config(Sensor, dgtl12, shootLimitRight, sensorTouch)
#pragma config(Motor,  port2,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontR,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightShooter,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           ballDirection, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftShooter,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           frontLeft,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int frontRight = frontR;
float pi = 3.1415;
void maxGyro(int deg);

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

int controlOfDrive = 0;
void leftshoot()
{
	motor[leftShooter] = 127;
	wait1Msec(1000);
	while(SensorValue[shootLimitLeft] == 0 || vexRT[Btn5D]);
	motor[leftShooter] = -0;
	wait1Msec(75);
}
void rightshoot()
{
	motor[rightShooter] = 127;
	wait1Msec(1000);
	while(SensorValue[shootLimitRight] == 0 || vexRT[Btn5D]);
	motor[rightShooter] = -0;
	wait1Msec(75);
}
#define M_PI 3.1415
// Converts degrees to radians.
#define degreesToRadians(angleDegrees) (angleDegrees * M_PI / 180.0)

// Converts radians to degrees.
#define radiansToDegrees(angleRadians) (angleRadians * 180.0 / M_PI)
#define trackwidth ((15.5)/12)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
typedef struct TYPE_POS
{
	float x;
	float y;
	float z;

	float x_tile;
	float y_tile

	float oldFWD;
	float oldSTR;
	float oldAngle;


	float distance_from_goal;
	float angle_to_turn;
	float angle_from_goal;




} TYPE_POS;

typedef struct {
	float leftEncoder;
	float rightEncoder;
	float centerEncoder;
	int gyroValue;

} ENCODER_DATA;
ENCODER_DATA eData;
TYPE_POS pData;
const int RED = 0;
const int BLUE = 1;
int alliance = BLUE;
const int DRIVER_BOX_SQUARE = 0;
const int FIELD_WALL_SQUARE = 1;
int starting_square = DRIVER_BOX_SQUARE;
task FPS {
	int GYRO_OFFSET = 900;
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	SensorValue[centerEncoder] = 0;
	SensorValue[gyro] = 0;
	if(alliance == BLUE)
	{
	pData.x = starting_square == DRIVER_BOX_SQUARE ? 2 : 1;
	pData.y = starting_square == DRIVER_BOX_SQUARE ? 1 : 2;
	}
	else if(alliance == RED)
	{
	pData.x = starting_square == DRIVER_BOX_SQUARE ? 9 : 11;
	pData.y = starting_square == DRIVER_BOX_SQUARE ? 1 : 2;
	}
	clearTimer(T1);
	while(1){
		float FWD, STR, RCW, dF, dS, dR;
		eData.leftEncoder = ((SensorValue[leftEncoder] / 360) * 10.205) / 12;  // Rotations * Circumfirence / 12
		eData.rightEncoder = ((SensorValue[rightEncoder] / 360) * 10.205) / 12;  // Rotations * Circumfirence / 12
		eData.centerEncoder = ((-SensorValue[centerEncoder] / 360) * 10.205) / 12;  // Rotations * Circumfirence / 12
		eData.gyroValue = SensorValue[gyro];

		// get updated follower wheel data
		FWD=(eData.leftEncoder+eData.rightEncoder)/2;           // feet
		STR=eData.centerEncoder;                 // feet
		RCW=degreesToRadians(eData.gyroValue/10);  // radians

		// compute the motions for this time step:
		dF=FWD-pData.oldFWD;  // feet
		dS=STR-pData.oldSTR;  // feet
		dR=RCW-pData.oldAngle;  // radians

		// compute new X, Y, Q position & orientation:
		pData.z+=dR/2;
		pData.y+=dF*sin(pData.z)+dS*cos(pData.z);
		pData.x+=dF*cos(pData.z)-dS*sin(pData.z);
		pData.z+=dR/2;

		pData.x_tile = pData.x * 12;
		pData.y_tile = pData.y * 12;

		// save for next iteration:
		pData.oldFWD=FWD;
		pData.oldSTR=STR;
		pData.oldAngle=RCW;
		if(alliance == BLUE)
		{
			pData.distance_from_goal = sqrt( pow(144-pData.x_tile,2) + pow(144-pData.y_tile,2) );
			int dx = 144-pData.x_tile;
			int dy = 144-pData.y_tile;
			pData.angle_from_goal = radiansToDegrees(atan(dx/dy));
		}
		else if(alliance = RED)
		{
			pData.distance_from_goal = sqrt( pow(144-pData.x_tile,2) + pow(0-pData.y_tile,2) );
			int dx = 144-pData.x_tile;
			int dy = 0-pData.y_tile;
			pData.angle_from_goal = radiansToDegrees(atan(dx/dy));
		}

		//writeDebugStreamLine("%d, %d, %d, %d, %d, %f, %f", Time10[T1], sensorValue[leftEncoder], sensorValue[rightEncoder], sensorValue[centerEncoder], sensorValue[gyro], pData.x, pData.y);
		wait1Msec(30);
	}
}

int CONROLOFDRIVE = 0;
int error;
float kP = 0.35;
int goal;
int errorForStop = 50; // 5 Degress * 10 Counts/Degree
void maxgyro(int deg) // Turn By Gyroscope
{
	controlOfDrive = 1;
	int deg10 = 10.8*deg;
	if(deg10 > 0)
	{
		deg10 += SensorValue[gyro];
		while(abs(SensorValue[gyro]) < abs(deg10))
		{
			motor[frontLeft] = 50;
			motor[backRight] = 50;
			motor[frontRight] = -50;
			motor[backLeft] = -50;
		}
		motor[frontLeft] = -10;
		motor[backRight] = -10;
		motor[frontRight] = 10;
		motor[backLeft] = 10;
		wait1Msec(200);
	}
	else
	{
		deg10 -= SensorValue[gyro];
		while(abs(SensorValue[gyro]) < abs(deg10))
		{
			motor[frontLeft] = -50;
			motor[backRight] = -50;
			motor[frontRight] = 50;
			motor[backLeft] = 50;
		}
		motor[frontLeft] = 50;
		motor[backRight] = 50;
		motor[frontRight] = -50;
		motor[backLeft] = -50;
		wait1Msec(200);
	}
	motor[frontLeft] = 0;
	motor[backRight] = -0;
	motor[frontRight] = -0;
	motor[backLeft] = -0;
	controlOfDrive = 0;
}


const int LEFT = 0;
const int RIGHT = 1;
int shooter = LEFT;

const int FULL_COURT = 0;
const int HALF_COURT = 1;
int leftShooterSetup = FULL_COURT;
int rightShooterSetup = HALF_COURT;

int ballReadyToLoad = 0;
int leftBallLoaded = 0;
int rightBallLoaded = 0;
int controlOfIntake = 0;
task checkLoaded
{
	ballReadyToLoad = 0;
	leftBallLoaded = 0;
	rightBallLoaded = 0;
}
void alignWithGoal()
{
	int angleToTurn = pData.angle_from_goal - (SensorValue[gyro]/10);
	if(alliance == RED)
		if(shooter == LEFT)
		angleToTurn += 3
	else
		angleToTurn += -3
	if(alliance == BLUE)
		if(shooter == LEFT)
		angleToTurn += -3
	else
		angleToTurn += 3
	maxgyro(angleToTurn);
}
void loadLeftShooter() // Stop = Btn6D
{
	controlOfIntake = 1;
	clearTimer(T4);
	while(!leftBallLoaded && !vexRT[Btn6D] && time1[T4] < 1250)
	{
		motor[intake] = -127;
		motor[ballDirection] = -127;
	}
	motor[intake] = 0;
	motor[ballDirection] = 0;
	controlOfIntake = 0;
}
void loadRightShooter() // Stop = Btn6D
{
	controlOfIntake = 1;
	clearTimer(T4);
	while(!rightBallLoaded && !vexRT[Btn6D] && time1[T4] < 1250)
	{
		motor[intake] = -127;
		motor[ballDirection] = 127;
	}
	motor[intake] = 0;
	motor[ballDirection] = 0;
	controlOfIntake = 0;
}
task shooterRoutine
{
	startTask(checkLoaded);
	while(1)
	{
		int lastSensorValue = 0;
		if(vexRT[Btn8D])
		{
			leftshoot();
		}
		else if(vexRT[Btn7D])
		{
			rightshoot();
		}

		motor[leftShooter] = 0;
		motor[rightShooter] = 0;
		motor[ballDirection] = 0;
		wait1Msec(50);
	}
}




void pre_auton()
{
	startTask(FPS);
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	leftshoot();
	rightshoot();
	motor[ballDirection] = 127;
	motor[intake] = -127;
	wait1Msec(1500);
	motor[ballDirection] = -127;
	wait1Msec(350);
	motor[ballDirection] = 75;
	rightshoot();

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	startTask(shooterRoutine);
	startTask(FPS);
	while (true)
	{
		const int ON = 1;
		const int OFF = 0;
		int fieldDrive = OFF;
		while(1)
		{
			int strafe = vexRT[Ch1];
			int fwd = vexRT[Ch2];
			if(fieldDrive == ON)
			{
				float curr_gyro_angle_radians = SensorValue[gyro]/10 * pi/180;
				float temp = fwd * cos( curr_gyro_angle_radians ) + strafe * sin( curr_gyro_angle_radians);
				strafe = -fwd * sin( curr_gyro_angle_radians ) + strafe * cos( curr_gyro_angle_radians );
				fwd = temp;
			}
			if(controlOfDrive == 0)
			{
				motor[frontR] = fwd - strafe- vexRT[Ch4];
				motor[frontLeft]= -fwd - strafe - vexRT[Ch4];
				motor[backLeft]= -fwd + strafe - vexRT[Ch4];
				motor[backRight]= fwd + strafe - vexRT[Ch4];
			}
			if(controlOfIntake == 0)
			{
				if(vexRT[Btn6U])
				{
					motor[intake] = -127;
				}
				else if(vexRT[Btn5U])
				{
					motor[intake] = 75;
				}
				else
				{
					motor[intake] = 0;
				}
				if(vexRT[Btn8R])
				{
					motor[ballDirection] = 127;
				}
				else if(vexRT[Btn7L])
				{
					motor[ballDirection] = -127;
				}
			}
		}
	}
}
